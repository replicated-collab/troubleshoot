name: Update Status on External Comment

on:
  issue_comment:
    types: [created]

jobs:
  update-status:
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request == null
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Require replicatedhq member
        id: member
        uses: ./.github/actions/require-replicatedhq-member
        continue-on-error: true
      - name: Update status when commenter is outside replicatedhq
        if: steps.member.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const commenter = context.payload.comment.user.login;
            const isClosed = context.payload.issue.state === 'closed';
            
            // Avoid bot loops
            if (commenter === 'replicated-collab-bot') {
              core.info('Commenter is replicated-collab-bot; skipping status update');
              return;
            }
            
            // If issue is closed, reopen it first
            if (isClosed) {
              core.info('Commenter is external and issue is closed; reopening issue');
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  state: 'open',
                });
                core.info('Issue reopened successfully');
              } catch (e) {
                core.info(`Failed to reopen issue: ${e.message}`);
                return;
              }
            }
            
            // Remove all status::* labels
            let labelsToRemove = [];
            try {
              const labels = await github.paginate(
                github.rest.issues.listLabelsOnIssue,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  per_page: 100,
                }
              );
              labelsToRemove = labels
                .map(l => l.name)
                .filter(name => name.startsWith('status::'));
            } catch (e) {
              core.info(`Failed to list labels: ${e.message}`);
              return;
            }
            
            if (labelsToRemove.length === 0) {
              core.info('Issue does not have status:: labels to clear');
            } else {
              core.info(`Removing status labels: ${labelsToRemove.join(', ')}`);
              for (const labelName of labelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.payload.issue.number,
                    name: labelName,
                  });
                  core.info(`Removed ${labelName} label`);
                } catch (e) {
                  core.info(`Skipping removal of label ${labelName}: ${e.message}`);
                }
              }
            }
            
            // Add status::open label
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                labels: ['status::open'],
              });
              core.info('Added status::open label');
            } catch (e) {
              core.info(`Failed to add status::open label: ${e.message}`);
            }

